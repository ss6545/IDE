/**
 * ******************************************************************************
 * @file    : sysctl.c
 * @brief   : SYSCTL module operations
 * @details : Provides setup function to alter MCLK and ULPCLK frequencies
 * @note    : ULPCLK is max 40MHz. Set to MCLK/2 when > 32MHz
 * @warning : Do not edit this file unless you know what you are doing!
 *          : You can brick your device with an incorrect configuration
 * 
 * @author tlk1160
 * @date 3/15/2025
 * ******************************************************************************
*/

#include <ti/devices/msp/msp.h>
#include "sysctl.h"

#include <stdint.h>

#if defined(__has_attribute)
#  if __has_attribute(fallthrough)
#    define FALLTHROUGH __attribute__((fallthrough))
#  else
#    define FALLTHROUGH ((void)0)
#  endif
#elif defined(__GNUC__) && __GNUC__ >= 7
#  define FALLTHROUGH __attribute__((fallthrough))
#else
#  define FALLTHROUGH ((void)0)
#endif

/* PARAM0 Addresses */
#define SYSCTL_SYSPLL_PARAM0_INPFREQ_32_48_MHZ (0x41C40034)
#define SYSCTL_SYSPLL_PARAM0_INPFREQ_16_32_MHZ (SYSCTL_SYSPLL_PARAM0_INPFREQ_32_48_MHZ - 0x00000008)
#define SYSCTL_SYSPLL_PARAM0_INPFREQ_08_16_MHZ (SYSCTL_SYSPLL_PARAM0_INPFREQ_16_32_MHZ - 0x00000008)
#define SYSCTL_SYSPLL_PARAM0_INPFREQ_04_08_MHZ (SYSCTL_SYSPLL_PARAM0_INPFREQ_08_16_MHZ - 0x00000008)

/* PARAM1 Addresses */
#define SYSCTL_SYSPLL_PARAM1_INPFREQ_32_48_MHZ (SYSCTL_SYSPLL_PARAM0_INPFREQ_32_48_MHZ + 0x00000004)
#define SYSCTL_SYSPLL_PARAM1_INPFREQ_16_32_MHZ (SYSCTL_SYSPLL_PARAM0_INPFREQ_16_32_MHZ + 0x00000004)
#define SYSCTL_SYSPLL_PARAM1_INPFREQ_08_16_MHZ (SYSCTL_SYSPLL_PARAM0_INPFREQ_08_16_MHZ + 0x00000004)
#define SYSCTL_SYSPLL_PARAM1_INPFREQ_04_08_MHZ (SYSCTL_SYSPLL_PARAM0_INPFREQ_04_08_MHZ + 0x00000004)

/* SYSOSC Defaults to 32MHz. */
// This is correct, even without set() so long as SYSOSC = 32MHz
static enum SYSCTL_SYSCLK_FREQ SystemMasterClock = SYSCLK_32MHZ;

/**
 * @brief Explicitly sets MCLK and ULPCLK frequencies through SYSPLL
 * @param[in] clk_freq - Desired clock frequency, specified by enum
 * @note MCLKfreq = (((32MHz / PDIV) * (QDIV + 1)) / CLK0_DIV)
 *       ULPCLKfreq = MCLKfreq / UDIV, ceil to 40MHz
 * @warning Be careful if editing this function.
 *          Incorrect SYSPLL configuration can brick the device
 */
void SYSCTL_SYSCLK_set(enum SYSCTL_SYSCLK_FREQ clk_freq) {
    /* Configure Flash Wait States for operating from SYSPLL */
    SYSCTL->SOCLOCK.MCLKCFG |= SYSCTL_MCLKCFG_FLASHWAIT_WAIT2;

    /* Set base 32MHz frequency */
    SYSCTL->SOCLOCK.SYSOSCCFG |= SYSCTL_SYSOSCCFG_FREQ_SYSOSCBASE;

    /* Explicitly disable HXFT source and SYSPLL for modifications */
    SYSCTL->SOCLOCK.HSCLKEN &= ~(SYSCTL_HSCLKEN_HFXTEN_ENABLE | SYSCTL_HSCLKEN_SYSPLLEN_ENABLE);

    /* Ensure that SYSPLL is disabled before modifying */
    while (!(SYSCTL->SOCLOCK.CLKSTATUS & SYSCTL_CLKSTATUS_SYSPLLOFF_MASK));

    /* Set SYSPLL reference clock */
    SYSCTL->SOCLOCK.SYSPLLCFG0 |= SYSCTL_SYSPLLCFG0_SYSPLLREF_SYSOSC;

    /* Save CPU cache configuration and modify */
    uint32_t cache_save = (CPUSS->CTL & (CPUSS_CTL_ICACHE_MASK | CPUSS_CTL_PREFETCH_MASK | CPUSS_CTL_LITEN_MASK));
    CPUSS->CTL = (CPUSS_CTL_PREFETCH_ENABLE | CPUSS_CTL_ICACHE_DISABLE | CPUSS_CTL_LITEN_ENABLE);

    /* Set SYSPLL PARAM0 address */
    // Following specifications on pg. 151 of reference manual, section 2.3.1.3.2
    SYSCTL->SOCLOCK.SYSPLLPARAM0 = SYSCTL_SYSPLL_PARAM0_INPFREQ_32_48_MHZ; // 16_32

    /* Set SYSPLL PARAM1 address */
    SYSCTL->SOCLOCK.SYSPLLPARAM1 = SYSCTL_SYSPLL_PARAM1_INPFREQ_32_48_MHZ;

    /* Restore CPU cache configuration */
    CPUSS->CTL = cache_save;

    /* Set PDIV (predivider) */
    // Set to DIV1 for faster startup
    SYSCTL->SOCLOCK.SYSPLLCFG1 |= SYSCTL_SYSPLLCFG1_PDIV_REFDIV1;

    // Note: There are intentional fall-throughs here to make the code more concise
    switch (clk_freq) {
        case SYSCLK_80MHZ:
            /* Set QDIV (feedback divider) */
            // Must be set from 2-127 (left shifted 8)
            // Note: Number adds 1 here
            SYSCTL->SOCLOCK.SYSPLLCFG1 |= ((4 << SYSCTL_SYSPLLCFG1_QDIV_OFS) & SYSCTL_SYSPLLCFG1_QDIV_MASK);
            FALLTHROUGH;
        case SYSCLK_64MHZ:
            if (clk_freq == SYSCLK_64MHZ)
                SYSCTL->SOCLOCK.SYSPLLCFG1 |= ((3 << SYSCTL_SYSPLLCFG1_QDIV_OFS) & SYSCTL_SYSPLLCFG1_QDIV_MASK);
            FALLTHROUGH;
        case SYSCLK_48MHZ:
            if (clk_freq == SYSCLK_48MHZ)
                SYSCTL->SOCLOCK.SYSPLLCFG1 |= ((2 << SYSCTL_SYSPLLCFG1_QDIV_OFS) & SYSCTL_SYSPLLCFG1_QDIV_MASK);
            
            /* Enable and set CLK0 output source and divider */
            SYSCTL->SOCLOCK.SYSPLLCFG0 |= (SYSCTL_SYSPLLCFG0_RDIVCLK0_CLK0DIV2 | SYSCTL_SYSPLLCFG0_ENABLECLK0_ENABLE);

            /* Set ULPCLK division */
            // Note: Must always remain below 40MHz
            SYSCTL->SOCLOCK.MCLKCFG |= SYSCTL_MCLKCFG_UDIV_DIVIDE2;
            break;
        case SYSCLK_32MHZ:
            SYSCTL->SOCLOCK.SYSPLLCFG0 |= (SYSCTL_SYSPLLCFG0_RDIVCLK0_CLK0DIV2 | SYSCTL_SYSPLLCFG0_ENABLECLK0_ENABLE);
            FALLTHROUGH;
        case SYSCLK_16MHZ:
            if (clk_freq == SYSCLK_16MHZ)
                SYSCTL->SOCLOCK.SYSPLLCFG0 |= (SYSCTL_SYSPLLCFG0_RDIVCLK0_CLK0DIV4 | SYSCTL_SYSPLLCFG0_ENABLECLK0_ENABLE);
            FALLTHROUGH;
        case SYSCLK_08MHZ:
            if (clk_freq == SYSCLK_08MHZ)
                SYSCTL->SOCLOCK.SYSPLLCFG0 |= (SYSCTL_SYSPLLCFG0_RDIVCLK0_CLK0DIV8 | SYSCTL_SYSPLLCFG0_ENABLECLK0_ENABLE);
            FALLTHROUGH;
        case SYSCLK_04MHZ:
            if (clk_freq == SYSCLK_04MHZ)
                SYSCTL->SOCLOCK.SYSPLLCFG0 |= (SYSCTL_SYSPLLCFG0_RDIVCLK0_CLK0DIV16 | SYSCTL_SYSPLLCFG0_ENABLECLK0_ENABLE);
            FALLTHROUGH;
        case SYSCLK_02MHZ:
            if (clk_freq == SYSCLK_02MHZ)
                SYSCTL->SOCLOCK.SYSPLLCFG0 |= (SYSCTL_SYSPLLCFG0_RDIVCLK0_CLK0DIV32 | SYSCTL_SYSPLLCFG0_ENABLECLK0_ENABLE);
            SYSCTL->SOCLOCK.SYSPLLCFG1 |= ((1 << SYSCTL_SYSPLLCFG1_QDIV_OFS) & SYSCTL_SYSPLLCFG1_QDIV_MASK);
            SYSCTL->SOCLOCK.MCLKCFG &= ~(SYSCTL_MCLKCFG_UDIV_MASK);
            break;
    }

    // Set global for getter
    SystemMasterClock = clk_freq;

    /* Renable SYSPLL */
    SYSCTL->SOCLOCK.HSCLKEN |= (SYSCTL_HSCLKEN_SYSPLLEN_ENABLE);

    /* Wait until SYSPLL startup has stabilized */
    while (SYSCTL->SOCLOCK.CLKSTATUS & SYSCTL_CLKSTATUS_SYSPLLOFF_MASK);

    /* Switch from SYSOSC to HSCLK (SYSPLL source) */
    SYSCTL->SOCLOCK.HSCLKCFG = SYSCTL_HSCLKCFG_HSCLKSEL_SYSPLL;

    /* Ensure the HSCLK source is valid */
    while (!(SYSCTL->SOCLOCK.CLKSTATUS & SYSCTL_CLKSTATUS_HSCLKGOOD_MASK));

    /* Switch MCLK from SYSOSC to HSCLK source */
    SYSCTL->SOCLOCK.MCLKCFG |= SYSCTL_MCLKCFG_USEHSCLK_ENABLE;

    /* Ensure MCLK is now sourced from HSCLK */
    while (!(SYSCTL->SOCLOCK.CLKSTATUS & SYSCTL_CLKSTATUS_HSCLKMUX_MASK));
}

/**
 * @brief Retrieves current MCLK value
 * @note Will return correct value even if set() was not called
 * @return Set MCLK value
 */
enum SYSCTL_SYSCLK_FREQ SYSCTL_SYSCLK_getMCLK(void) {
    return SystemMasterClock;
}

/**
 * @brief Retrieves current ULPCLK value
 * @note Will return correct value even if set() was not called
 * @return Current ULPCLK value, set by MCLK
 */
enum SYSCTL_SYSCLK_FREQ SYSCTL_SYSCLK_getULPCLK(void) {
    // If greater than 32MHz, ULPCLK = MCLK/2
    if (SystemMasterClock > SYSCLK_32MHZ) {
        return (SystemMasterClock >> 1);
    } else {
        return SystemMasterClock;
    }
}
